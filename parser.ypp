%{
    #include "hw3_output.hpp"
    
    #include <iostream>
    #include <cstring>
    #include "symbol_tables_stack.hpp"
    #include "registers.hpp"
    #include "bp.hpp"
    //TODO:
    /*
    #define EMPTY_VAR "EMPTY"
    */
    extern int yylineno;
    int yylex();
    void yyerror( const char* s);
    
    using namespace output;

    symbol_tables_stack _stack = symbol_tables_stack();
    bool notBool( char* type);
    bool byteTooLarge(int value);
    bool typesDontMatch( char* LHS_type,  char* RHS_type);
    bool notIntOrByte( char* converter_type,  char* converted_type);
    bool can_type_be_compared(char* t1,char* t2);
    bool expList_not_valid(string func_name, string exp_list);
    bool isVoid();
    char* biggerType(char* first, char* second);
    char* join(char* s1,char* s2);


//TODO:ADD SOME OF THE FUNCTIONS BELOW
/*
    vector<string> charToVector(const char* list);
    std::string typeToLLVMType(const char* type);
    std::string opToCommandName(const char* op, const char* type);
    void resolveJumpToNextLine(E* exp);
    bool notLastBool(vector<string>::iterator it, vector<string>::iterator end);
    CodeBuffer& cbf = CodeBuffer::instance();
    Registers& rgs = Registers::instance();
*/


    
%}
%define parse.error verbose;

%nonassoc VOID;
%nonassoc INT;
%nonassoc BYTE;
%nonassoc B;
%nonassoc BOOL;
%nonassoc OVERRIDE;
%nonassoc TRUE;
%nonassoc FALSE;
%nonassoc RETURN;

%token V;
%token ERROR;
%nonassoc IF;
%nonassoc WHILE;
%nonassoc BREAK;
%nonassoc CONTINUE;
%nonassoc SC;
%nonassoc COMMA;
%nonassoc LBRACE;
%nonassoc RBRACE;
%nonassoc ID;                                                                      
%nonassoc NUM;    
%nonassoc STRING;

%right ASSIGN;

%left OR;
%left AND;


%left EQ_RELOP;
%left RE_RELOP;
%left PM_BINOP;
%left MD_BINOP;

%right NOT;
%left LPAREN;
%left RPAREN;
%nonassoc ELSE;

%%
Program
    : {//TODO: /*GO TO REFRENCE!*/}
    Funcs {
        if (yychar == YYEOF) {
            _stack.validateMainFunction(yylineno);
            _stack.pop_scope();
            //TODO:
            /*
            cbf.printGlobalBuffer();
            cbf.printCodeBuffer();
            */
        }
        
    }
    ;

Funcs
    : FuncDecl Funcs {/*empty*/}
    |/*epsilon*/ {/*empty*/}
    ;

FuncDecl
    : OverRide RetType ID LPAREN Formals
    { 
        _stack.insert(string($3.name), string(join(join($5.type ,"->"),$2.type)), true, $1.intVal, yylineno);
        //TODO:REFRENCE
        /*
        cbf.formalsFuncGenerator(...);
        */
    
    }
    RPAREN LBRACE 
    {_stack.push_scope();_stack.symbol_table_add_function_parameter_entries(string($5.name), string($5.type), yylineno);} 
    Statements RBRACE 
    {_stack.pop_scope();
    
    //TODO: REFRENCE
    /*
    cbf.funcDeclGen(...);
    */
    
    }
    ;
OverRide
    :/*epsilon*/ {$$.intVal = false;}
    | OVERRIDE {$$.intVal = true;}
    ;

RetType
    : VOID { $$.type=$1.type; } 
    | Type { $$.type=$1.type; }
    ;

Formals
    : /*epsilon*/ {$$.type = ""; $$.name = "";  }
    |FormalsList {$$.type = $1.type; $$.name = $1.name;}
    ;

FormalsList
    : FormalDecl {$$.type = $1.type; $$.name = $1.name;}
    | FormalDecl COMMA FormalsList {$$.type = join(join($1.type ,","), $3.type);
                                    $$.name = join(join($1.name ,",") , $3.name);}
    ;
FormalDecl
    : Type ID { $$.type = $1.type ; $$.name = $2.name; }
    ;

Statements
    : Statement 
    {
        //TODO: ADD
        /*
        $$.nextList = $1.nextList;
        $$.breakList = $1.breakList;
        $$.contList = $1.contList;
        */
        }
    | Statements
    {
        //TODO: add
        /*
        if(($1.nextList).size() > 0)
        {
          string label = cbf.genLabel();
          cbf.bpatch($1.nextList, label);
        }
        */
    } Statement 
    {
        //TODO: ADD
        /*
        $$.nextList = $3.nextList; 
        $$.breakList = cbf.merge($1.breakList, $3.breakList);
        $$.contList = cbf.merge($1.contList, $3.contList);
        */
        }
    ;
Statement 
    : LBRACE {_stack.push_scope();} Statements RBRACE 
    {
        _stack.pop_scope();
        //TODO: ADD
        /*
        $$.nextList = $3.nextList;
        $$.breakList = $3.breakList;
        $$.contList = $3.contList;
        */
    }
    | Type ID SC { 
        _stack.insert($2.name , $1.type, false, false, yylineno);
        $2.type=$1.type;
        //TODO: REFRENCE
        /*
        varDefintionGenerate(...);
        */
        
        }
    | Type ID ASSIGN Exp SC 
    {
        if(typesDontMatch($1.type, $4.type)) errorMismatch(yylineno);
        $2.type=$1.type; _stack.insert($2.name , $2.type, false, false, yylineno);
        //TODO: REFRENCE
        /*
        varDefintionAndAssignmentGenerate(...);
        */
        }
    | ID ASSIGN {
        if(!_stack.nameExists($1.name) || _stack.isFunc($1.name)) errorUndef(yylineno, $1.name);
        
        //TODO: REFRENCE
        /*
        midAssignmentGenerate(...);
        */
        } 
        Exp SC { 
            if(typesDontMatch(_stack.getType($1.name).data(), $4.type)) errorMismatch(yylineno);
        //TODO: REFRENCE
        /*
        endAssignmentGenerate(...);
        */
        }
    | Call SC {
      //TODO: ADD
      /*
      $$.type = $1.type;
      $$.var = rgs.freshVar();
      resolveJumpToNextLine(&($1));
      cbf.emit($1.label);
      */ }
    | RETURN SC { 
        if(!isVoid()||_stack.getCurrentfunctionreturnType()!="VOID") errorMismatch(yylineno); 
        //TODO: ADD
        /*
        cbf.emit("ret void");
        */
        }
    | RETURN Exp SC {
        if(isVoid()||!_stack.is_desired_return_type(string($2.type),_stack.getCurrentfunctionreturnType(),false)) errorMismatch(yylineno);
        //TODO: REFRENCE
        /*
        returnNonVoidGenerate(...);
        */
        }
    | IF NEW_SCOPE_MARKER LPAREN CHECK_TYPE_MARKER RPAREN Statement POP_SCOPE_MARKER
{
        //TODO: ADD
        /*
        $$.nextList = cbf.merge($4.falseList, $6.nextList);
        $$.nextList = cbf.merge($$.nextList, $7.nextList);
        $$.breakList = $6.breakList;
        $$.contList = $6.contList;
        */
}
    | IF NEW_SCOPE_MARKER LPAREN CHECK_TYPE_MARKER RPAREN Statement POP_SCOPE_MARKER ELSE
     {
        _stack.push_scope();

        //TODO: ADD
        /*
        $$.nextList = $7.nextList;
        string label = cbf.genLabel();
        cbf.bpatch($4.falseList, label);
        */
    } 
     
     Statement 
    {
        _stack.pop_scope();
        
        //TODO: ADD
        /*
        int line = cbf.emit("br label @");
        auto temp = cbf.merge(cbf.makelist({line, FIRST}), $6.nextList);
        temp = cbf.merge(temp, $9.nextList);
        $$.nextList = cbf.merge(temp, $10.nextList);
        $$.breakList = cbf.merge($6.breakList, $10.breakList);
        $$.contList = cbf.merge($6.contList, $10.contList);
        */
    }
    
    
    | WHILE 
    {
        _stack.push_scope();_stack.updateInWhile(true);
        //TODO: ADD
        /*
        //NIKITA'S COMMENT: There must be a jump to a label BEFORE it definition....:
        int line = cbf.emit("br label @");
        $$.label = cbf.genLabel();
        cbf.bpatch(cbf.makelist({line, FIRST}), $$.label);
        */
    } 
    LPAREN Exp 
    { 
        if(notBool($4.type)) errorMismatch(yylineno);
        //TODO: ADD
        /*
        resolveJumpToNextLine(&($4));
        $$.label = cbf.genLabel();
        cbf.bpatch($4.trueList, $$.label);
        */
    } 
    RPAREN Statement 
    {
        _stack.updateInWhile(false);
        _stack.pop_scope();
        
        //TODO: ADD
        /*
        cbf.bpatch($7.contList, $2.label);
        cbf.bpatch($7.nextList, $2.label);
        $$.nextList = cbf.merge($4.falseList, $7.breakList);
        cbf.emit("br label %" + $2.label);
        */

    }
    | BREAK SC 
    { 
        if(!_stack.inWhileLoop()) errorUnexpectedBreak(yylineno);
                
        //TODO: ADD
        /*        
        $$.breakList = cbf.makelist({cbf.emit("br label @"), FIRST});
        */
    }
    | CONTINUE SC { 
        if(!_stack.inWhileLoop()) errorUnexpectedContinue(yylineno);
        //TODO: ADD
        /*
        $$.contList = cbf.makelist({cbf.emit("br label @"), FIRST});
        */
        }
    ;

Call
    : ID LPAREN ExpList RPAREN { 
        _stack.validateCall(string($1.name), string($3.type), yylineno);
        $$.name = $1.name; 
        $$.type = _stack.getFuncReturnType(string($1.name),string($3.type)).data();
        //TODO: REFRENCE
        /*
        functionCallGenerate(...);
        */
    }
    | ID LPAREN RPAREN 
    { 
        _stack.validateCall(string($1.name), "",yylineno);
        $$.name = $1.name; 
        $$.type = _stack.getFuncReturnType($1.name,"").data();
        //TODO: ADD
        /*
        $$.jumpList = cbf.makelist({cbf.emit("br label @"), FIRST});
        $$.startLabel = cbf.genLabel();        
        $$.varInitLabel = $$.startLabel; 
        string str_name($1.name);
        string call_str = "call " + typeToLLVMType($$.type) + " @" + str_name + "()";
        $$.label = call_str;
        */

    }
    ;
NEW_SCOPE_MARKER 
    : /*epsilon*/{_stack.push_scope();}
    ;
POP_SCOPE_MARKER
    : /*epsilon*/ 
    {
        _stack.pop_scope();
        //TODO: ADD
        /*
        int line = cbf.emit("br label @");
        $$.nextList = cbf.makelist({line, FIRST});
        */
    }
    ;
CHECK_TYPE_MARKER
    : Exp {
        if(notBool($1.type)) errorMismatch(yylineno);
        //TODO: ADD
        /*
        resolveJumpToNextLine(&($1));
        int line = cbf.emit("br label @");
        string label = cbf.genLabel();
        cbf.bpatch(cbf.makelist({line, FIRST}), label);
        cbf.bpatch($1.trueList, label);
        $$.falseList = $1.falseList;
        $$.trueList = $1.trueList;
        */
        }
    ;
ExpList
    : Exp 
    { 
    $$.type = $1.type; 
    //TODO: ADD
    /*
    ($$.trueListList).push_back($1.trueList); 
        ($$.falseListList).push_back($1.falseList);
        if(($1.startLabel).length() == 0)
            $1.startLabel = " ";
        $$.startLabel = $1.startLabel;
        $$.jumpList = $1.jumpList;
        $$.varInitLabel = $1.varInitLabel;

    */
    }
    | Exp COMMA ExpList 
    {
        //TODO: ADD
        /*
        resolveJumpToNextLine(&($3));
        */

        $$.type = join(join($1.type, ","),$3.type);
        
        //TODO: ADD
        /*
        $$.var = $1.var + "," + $3.var;
        ($3.trueListList).insert(($3.trueListList).begin(), $1.trueList);
        $$.trueListList = $3.trueListList;
        ($3.falseListList).insert(($3.falseListList).begin(), $1.falseList);
        $$.falseListList = $3.falseListList;
        if(($1.startLabel).length() == 0)
        $1.startLabel = " ";
        $$.startLabel = $1.startLabel + "," + $3.startLabel;
        $$.jumpList = $1.jumpList; 
        $$.varInitLabel = $1.varInitLabel;
        */
    }
    ;

Type
    : INT { $$.type = $1.type; }
    | BYTE { $$.type = $1.type; }
    | BOOL { $$.type = $1.type; }
    ;

//TODO: REFRENCE FOR ALL EXP->something
/*
*/
Exp
    : LPAREN Exp RPAREN {
        $$.type = $2.type;
        }
    | Exp MD_BINOP Exp %prec MD_BINOP { if(notIntOrByte($1.type,$3.type)) errorMismatch(yylineno); $$.type = biggerType($1.type, $3.type); }
    | Exp PM_BINOP Exp %prec PM_BINOP { if(notIntOrByte($1.type,$3.type)) errorMismatch(yylineno); $$.type = biggerType($1.type, $3.type); }
    | ID {_stack.validateId(string($1.name),yylineno); $$.type = _stack.getType(string($1.name)).data();}
    | Call { $$.type=$1.type; }
    | NUM { $$.type=$1.type;  }
    | NUM B {if(byteTooLarge($1.intVal)) {errorByteTooLarge(yylineno, $1.strVal);} $$.type=$2.type; }
    | STRING { $$.type=$1.type; }
    | TRUE { $$.type=$1.type; }
    | FALSE { $$.type=$1.type; }
    | NOT Exp { if(notBool($2.type)) errorMismatch(yylineno); $$.type=$2.type; }
    | Exp AND Exp { if(notBool($1.type) || notBool($3.type)) errorMismatch(yylineno); $$.type=$1.type; }
    | Exp OR Exp { if(notBool($1.type) || notBool($3.type)) errorMismatch(yylineno); $$.type=$1.type; }
    | Exp EQ_RELOP Exp %prec EQ_RELOP { if(notIntOrByte($1.type,$3.type)) {errorMismatch(yylineno);} $$.type = "BOOL";}
    | Exp RE_RELOP Exp %prec RE_RELOP { if(notIntOrByte($1.type,$3.type)) {errorMismatch(yylineno);} $$.type = "BOOL"; }
    | LPAREN Type RPAREN Exp {if(notIntOrByte($2.type,$4.type)) errorMismatch(yylineno); $$.type = $2.type;}
    ;

%%
char* join(char* s1, char* s2)
{
    
    int str_len=strlen(s1)+strlen(s2);
    char* joined_str = (char*)malloc(sizeof(char)*(str_len+1));
    strcpy(joined_str,s1);
    strcat(joined_str,s2);
    
    //not freeing memory, might be a problem atm.

    return joined_str;
}

bool notBool( char* type)
{
    return strcmp(type,"BOOL")!=0;
}

bool byteTooLarge(int value)
{
    return value > 255;

}
bool typesDontMatch(  char* LHS_type,  char* RHS_type)
{
    //printf("val:%d\n",strcmp(LHS_type,RHS_type));
    if (strcmp(LHS_type,RHS_type)!=0 && ( (strcmp(LHS_type,"INT")!=0) || (strcmp(RHS_type,"BYTE")!=0) ) )
    {
        return true;
    }
    else
    {
    return false;
    }
}

bool notIntOrByte( char* converter_type,  char* converted_type)
{
    
    if((strcmp(converter_type,"INT")==0 && strcmp(converted_type,"BYTE")==0)
         ||(strcmp(converter_type,"BYTE")==0 && strcmp(converted_type,"INT")==0)
         ||(strcmp(converter_type,"INT")==0 && strcmp(converted_type,"INT")==0)
         ||(strcmp(converter_type,"BYTE")==0 && strcmp(converted_type,"BYTE")==0))
         {
            
            return false;
         }
    return true;
}

bool isVoid()
{
    string func_ret_type = _stack.getCurrentfunctionreturnType();
    return strcmp(func_ret_type.data(),"VOID")==0;
}

char* biggerType(char* first, char* second)
{
    return strcmp(second,"BYTE")==0?second:first;
}

int main()
{
    return yyparse();
}

void yyerror( const char*  s ) 
{
    errorSyn(yylineno);
}