%{
    #include "hw3_output.hpp"
    
    #include <iostream>
    #include <cstring>
    #include "symbol_tables_stack.hpp"
    #include "register.hpp"
    #include "bp.hpp"
    #include "parser_helper.hpp"

    #define VAR_EMPTY_STR "EMPTY"
    
    extern int yylineno;
    int yylex();
    void yyerror( const char* s);
    
    using namespace output;

    symbol_tables_stack _stack = symbol_tables_stack();
    bool notBool( char* type);
    bool byteTooLarge(int value);
    bool typesDontMatch( char* LHS_type,  char* RHS_type);
    bool notIntOrByte( char* converter_type,  char* converted_type);
    bool can_type_be_compared(char* t1,char* t2);
    bool expList_not_valid(string func_name, string exp_list);
    bool isVoid();
    char* biggerType(char* first, char* second);
    char* join(char* s1,char* s2);


//TODO:ADD SOME OF THE FUNCTIONS BELOW
/*
    bool notLastBool(vector<string>::iterator it, vector<string>::iterator end);
*/


    
%}
%define parse.error verbose;

%nonassoc VOID;
%nonassoc INT;
%nonassoc BYTE;
%nonassoc B;
%nonassoc BOOL;
%nonassoc OVERRIDE;
%nonassoc TRUE;
%nonassoc FALSE;
%nonassoc RETURN;

%token V;
%token ERROR;
%nonassoc IF;
%nonassoc WHILE;
%nonassoc BREAK;
%nonassoc CONTINUE;
%nonassoc SC;
%nonassoc COMMA;
%nonassoc LBRACE;
%nonassoc RBRACE;
%nonassoc ID;                                                                      
%nonassoc NUM;    
%nonassoc STRING;

%right ASSIGN;

%left OR;
%left AND;


%left EQ_RELOP;
%left RE_RELOP;
%left PM_BINOP;
%left MD_BINOP;

%right NOT;
%left LPAREN;
%left RPAREN;
%nonassoc ELSE;

%%
Program
    : {initDeclarations();}
    Funcs {
        if (yychar == YYEOF) {
            _stack.validateMainFunction(yylineno);
            _stack.pop_scope();
            printGlobalAndCodeBuffer();
        }    
    }
    ;

Funcs
    : FuncDecl Funcs {/*empty*/}
    |/*epsilon*/ {/*empty*/}
    ;

FuncDecl
    : OverRide RetType ID LPAREN Formals
    { 
        string llvm_name = rgs.freshVar(string($3.name),true); 
        _stack.insert(string($3.name), string(join(join($5.type ,"->"),$2.type)),llvm_name, true, $1.intVal, yylineno);
        declareFunction(/*is_override =*/ $1.intVal,
                        /*func_name=*/ string($3.name),
                        /*func_arguments_type_string=*/ string($5.type),
                        /*func_arguments_type_string=*/ string($5.name),
                        /*fresh_func_name*/ llvm_name); 
    }
    RPAREN LBRACE 
    {_stack.push_scope();_stack.symbol_table_add_function_parameter_entries(string($5.name), string($5.type), yylineno);} 
    Statements RBRACE 
    {
        _stack.pop_scope();
        closeFunction(/*nextlist=*/$10.nextList, /*func_return_type=*/  string($2.type));
    }
    ;
OverRide
    :/*epsilon*/ {$$.intVal = false;}
    | OVERRIDE {$$.intVal = true;}
    ;

RetType
    : VOID { $$.type=$1.type; } 
    | Type { $$.type=$1.type; }
    ;

Formals
    : /*epsilon*/ {$$.type = ""; $$.name = "";  }
    |FormalsList {$$.type = $1.type; $$.name = $1.name;}
    ;

FormalsList
    : FormalDecl {$$.type = $1.type; $$.name = $1.name;}
    | FormalDecl COMMA FormalsList {$$.type = join(join($1.type ,","), $3.type);
                                    $$.name = join(join($1.name ,",") , $3.name);}
    ;
FormalDecl
    : Type ID { $$.type = $1.type ; $$.name = $2.name; }
    ;

Statements
    : Statement 
    {
        $$.nextList = $1.nextList;
        $$.breakList = $1.breakList;
        $$.contList = $1.contList;
        }
    | Statements 
    { bpVector($1.nextList);} 
     Statement 
    {
        $$.nextList = $3.nextList; 
        $$.breakList = cbf.merge($1.breakList, $3.breakList);
        $$.contList = cbf.merge($1.contList, $3.contList);
        }
    ;
Statement 
    : LBRACE {_stack.push_scope();} Statements RBRACE 
    {
        _stack.pop_scope();
        $$.nextList = $3.nextList;
        $$.breakList = $3.breakList;
        $$.contList = $3.contList;
    }
    | Type ID SC { 
        string llvm_name = rgs.freshVar(string($2.name),false);
        $$.llvm_name = llvm_name;
        $$.name = $2.name;
        _stack.insert($2.name , $1.type, llvm_name, false, false, yylineno);
        $2.type=$1.type;
        $$.jumpList = cbf.makelist({cbf.emit("br label @"), FIRST});
        $$.startLabel = cbf.genLabel();
        cbf.bpatch($$.jumpList, $$.startLabel);
        varDefintionGenerate(/*varType*/string($1.type),
        /*var_name*/llvm_name); 
        }
    | Type ID ASSIGN Exp SC 
    {
        if(typesDontMatch($1.type, $4.type)) 
        {
            errorMismatch(yylineno);
        }
        $$.llvm_name = rgs.freshVar(string($2.name),false);
        $$.name = $2.name;
        $2.type=$1.type; _stack.insert($2.name , $2.type, $$.llvm_name, false, false, yylineno);     
        varDefintionAndAssignmentGenerate(/*llvm_var*/$$.llvm_name,
                             /*number value*/$4.llvm_name,
                             /*exp_type*/string($4.type),   
                             /*exp_true_list*/$4.trueList,
                             /*exp_false_list*/$4.falseList);
        
    }
    | ID ASSIGN {
        if(!_stack.nameExists($1.name) || _stack.isFunc($1.name)) errorUndef(yylineno, $1.name);
        $$.name = $1.name;
        } 
        Exp SC { 
            if(typesDontMatch(_stack.getType($1.name).data(), $4.type)) errorMismatch(yylineno);
        //TODO: REFRENCE
        /*
        endAssignmentGenerate(...);
        */
        }
    | Call SC {

      $$.type = $1.type;
      $$.llvm_name = rgs.freshVar();
      //TODO: refference
      
      resolve_jump_next_line(string($1.startLabel),$1.jumpList);
      cbf.emit($1.label);
       }
    | RETURN SC { 
        if(!isVoid()||_stack.getCurrentfunctionreturnType()!="VOID") errorMismatch(yylineno); 
        cbf.emit("ret void");
        }
    | RETURN Exp SC {
        if(isVoid()||!_stack.is_desired_return_type(string($2.type),_stack.getCurrentfunctionreturnType(),false)) errorMismatch(yylineno);
        resolve_jump_next_line(string($2.startLabel),$2.jumpList);
        if(strcmp($2.type, "BOOL") == 0)
        {
            $2.llvm_name = rgs.freshVar();
            emitBool($2.llvm_name, $2.trueList,$2.falseList);
    
        }
        cbf.emit("ret i32 " + $2.llvm_name);



        }
    | IF NEW_SCOPE_MARKER LPAREN CHECK_TYPE_MARKER RPAREN Statement POP_SCOPE_MARKER
{    
        $$.nextList = cbf.merge($4.falseList, $6.nextList);
        $$.nextList = cbf.merge($$.nextList, $7.nextList);
        $$.breakList = $6.breakList;
        $$.contList = $6.contList;
}
    | IF NEW_SCOPE_MARKER LPAREN CHECK_TYPE_MARKER RPAREN Statement POP_SCOPE_MARKER ELSE
     {
        _stack.push_scope();
        $$.nextList = $7.nextList;
        bpVector($4.falseList);

    } Statement 
    {
        //TODO: return to understand
        _stack.pop_scope();
        int line = cbf.emit("br label @");
        auto temp = cbf.merge(cbf.makelist({line, FIRST}), $6.nextList);
        temp = cbf.merge(temp, $9.nextList);
        $$.nextList = cbf.merge(temp, $10.nextList);
        $$.breakList = cbf.merge($6.breakList, $10.breakList);
        $$.contList = cbf.merge($6.contList, $10.contList);
        
    }
    
    
    | WHILE 
    {
        _stack.push_scope();_stack.updateInWhile(true);
        //TODO: understand
        //NIKITA'S COMMENT: There must be a jump to a label BEFORE it definition....:
        int line = cbf.emit("br label @");
        $$.label = cbf.genLabel();
        const auto& list = cbf.makelist({line, FIRST});
        bpVector(list, string($$.label));
    } 
    LPAREN Exp 
    { 
        if(notBool($4.type)) errorMismatch(yylineno);
        //TODO: understand
        
        resolve_jump_next_line(string($4.startLabel),$4.jumpList);
        

        $$.label = cbf.genLabel();
        bpVector($4.trueList, string($$.label));
        
    } 
    RPAREN Statement 
    {
        //todo understand
        _stack.updateInWhile(false);
        _stack.pop_scope();
        bpVector($7.contList,string($2.label));
        bpVector($7.nextList,string($2.label));
        $$.nextList = cbf.merge($4.falseList, $7.breakList);
        cbf.emit("br label %" + $2.label);


    }
    | BREAK SC 
    { 
        if(!_stack.inWhileLoop()) errorUnexpectedBreak(yylineno);
                
       
        $$.breakList = cbf.makelist({cbf.emit("br label @"), FIRST});
        
    }
    | CONTINUE SC { 
        if(!_stack.inWhileLoop()) errorUnexpectedContinue(yylineno);
        $$.contList = cbf.makelist({cbf.emit("br label @"), FIRST});
        }
    ;

Call
    : ID LPAREN ExpList RPAREN { 
        //todo understand
        _stack.validateCall(string($1.name), string($3.type), yylineno);
        $$.name = $1.name; 
        $$.type = _stack.getFuncReturnType(string($1.name),string($3.type)).data();
        //TODO: REFRENCE
        /*
        functionCallGenerate(...);
        */
    }
    | ID LPAREN RPAREN 
    { 
        //todo understand
        _stack.validateCall(string($1.name), "",yylineno);
        $$.name = $1.name; 
        $$.type = _stack.getFuncReturnType($1.name,"").data();
        $$.jumpList = cbf.makelist({cbf.emit("br label @"), FIRST});
        $$.startLabel = cbf.genLabel();        
        string str_name($1.name);
        string call_str = "call " + convertToLLVMType(string($$.type)) + " @" + str_name + "()";
        $$.label = call_str;
        

    }
    ;
NEW_SCOPE_MARKER 
    : /*epsilon*/{_stack.push_scope();}
    ;
POP_SCOPE_MARKER
    : /*epsilon*/ 
    {
        //todo understand
        _stack.pop_scope();
        int line = cbf.emit("br label @");
        $$.nextList = cbf.makelist({line, FIRST});
       
    }
    ;
CHECK_TYPE_MARKER
    : Exp {
        if(notBool($1.type)) errorMismatch(yylineno);
        //TODO: UNDERSTAND
        resolve_jump_next_line(string($1.startLabel),$1.jumpList);
        int line = cbf.emit("br label @");
        string label = cbf.genLabel();
        pair<int,BranchLabelIndex> item = {line, FIRST};
        auto list = cbf.makelist(item);
        bpVector(list, label);
        bpVector($1.trueList, label); // we want same label as before, hence do not delete label.
        $$.falseList = $1.falseList;
        $$.trueList = $1.trueList;
        }
    ;
ExpList
    : Exp 
    { 
    $$.type = $1.type; 
    //TODO: understand

    ($$.trueListList).push_back($1.trueList); 
    ($$.falseListList).push_back($1.falseList);
    if(($1.startLabel).length() == 0)
            $1.startLabel = " ";
    $$.startLabel = $1.startLabel;
    $$.jumpList = $1.jumpList;
    }
    | Exp COMMA ExpList 
    {
        //TODO: ADD and Understand
        
        resolve_jump_next_line(string($3.startLabel),$3.jumpList);
        

        $$.type = join(join($1.type, ","),$3.type);
        

        $$.llvm_name = $1.llvm_name + "," + $3.llvm_name;
        ($3.trueListList).insert(($3.trueListList).begin(), $1.trueList);
        $$.trueListList = $3.trueListList;
        ($3.falseListList).insert(($3.falseListList).begin(), $1.falseList);
        $$.falseListList = $3.falseListList;
        if(($1.startLabel).length() == 0)
        $1.startLabel = " ";
        $$.startLabel = $1.startLabel + "," + $3.startLabel;
        $$.jumpList = $1.jumpList; 
    }
    ;

Type
    : INT { $$.type = $1.type; }
    | BYTE { $$.type = $1.type; }
    | BOOL { $$.type = $1.type; }
    ;
Exp
    : LPAREN Exp RPAREN {
        //todo understand
        $$.type = $2.type;
        $$.llvm_name = $2.llvm_name;
        $$.trueList = $2.trueList;
        $$.falseList = $2.falseList;
        $$.jumpList = $2.jumpList;
        $$.startLabel = $2.startLabel;
        }
    | Exp MD_BINOP Exp %prec MD_BINOP {
         if(notIntOrByte($1.type,$3.type)) errorMismatch(yylineno); $$.type = biggerType($1.type, $3.type);
         //TODO : understand
            $$.llvm_name = rgs.freshVar();
            $$.jumpList = $1.jumpList;
            $$.startLabel = $1.startLabel;
            validateBinop(string($2.name), $3.llvm_name);
            
            $$.llvm_name = rgs.freshVar();
            
            cbf.emit($$.llvm_name + " = " + opcode_to_cmd($2.name, $$.type) + " i32 " + $1.llvm_name + ", " + $3.llvm_name);
            if(strcmp($$.type, "BYTE") == 0)
            {
                string new_var = rgs.freshVar();
                cbf.emit(new_var + " = and i32 "+ $$.llvm_name +", 255");
                $$.llvm_name = new_var;
            }
            
          }
    | Exp PM_BINOP Exp %prec PM_BINOP {
         if(notIntOrByte($1.type,$3.type)) errorMismatch(yylineno); $$.type = biggerType($1.type, $3.type);
            resolve_jump_next_line(string($3.startLabel),$3.jumpList);
            $$.llvm_name = rgs.freshVar();
            $$.type = biggerType($1.type, $3.type);
            $$.startLabel = $1.startLabel;
            $$.jumpList = $1.jumpList;

            cbf.emit($$.llvm_name + " = " + opcode_to_cmd(string($2.name), string($$.type)) + " i32 " + $1.llvm_name + ", " + $3.llvm_name);
            if(strcmp($$.type, "BYTE") == 0)
            {
                string new_reg = rgs.freshVar();
                cbf.emit(new_reg + " = and i32 "+ $$.llvm_name +", 255");
                $$.llvm_name = new_reg;
            }
        }
    | ID {
        _stack.validateId(string($1.name),yylineno); 
        $$.type = _stack.getType(string($1.name)).data();
        $$.llvm_name = _stack.getLlvmName(string($1.name));
        //$$.intVal = _stack.getIntVal(string($1.name))
        }
    | Call { $$.type=$1.type; }
    | NUM { $$.type=$1.type; 
        $$.type = $1.type;
        $$.name = $1.name;
        $$.llvm_name = to_string($$.intVal);
        $$.jumpList = cbf.makelist({cbf.emit("br label @"), FIRST});
        $$.startLabel = cbf.genLabel();
        }
    | NUM B {if(byteTooLarge($1.intVal)) {errorByteTooLarge(yylineno, $1.strVal);}
          $$.name = $1.name;
          $$.type= $2.type; 
          $$.llvm_name = to_string($$.intVal);
          $$.jumpList = cbf.makelist({cbf.emit("br label @"), FIRST});
          $$.startLabel = cbf.genLabel();
          }

    | STRING 
    { 
        $$.type=$1.type;
        string global_var = rgs.freshVar(".g_ig_", true);
        $$.llvm_name = rgs.freshVar();
        $$.jumpList = cbf.makelist({cbf.emit("br label @"), FIRST});
        string str($1.strVal);
        str = str.substr(1, str.length() - 2);
        $$.startLabel = cbf.genLabel();
        $$.name = str.data();
        int len = strlen($$.name) + 1;
        cbf.emitGlobal(global_var + " = constant [" + to_string(str.length() + 1) + " x i8] c\"" + str + "\\00\"");
        cbf.emit($$.llvm_name + " = getelementptr ["+to_string(len)+" x i8], ["+to_string(len)+" x i8]* "+(global_var)+", i32 0, i32 0"); 
    }
    | TRUE { $$.type=$1.type;
        $$.jumpList = cbf.makelist({cbf.emit("br label @"), FIRST});
        $$.startLabel = cbf.genLabel(); 
        $$.type = $1.type;
        int true_line = cbf.emit("br label @");
        int false_line = cbf.emit("br label @");
        $$.trueList = cbf.makelist({true_line, FIRST});
        $$.falseList = cbf.makelist({false_line, FIRST});
        $$.llvm_name = VAR_EMPTY_STR; }
    | FALSE { $$.type=$1.type;
          $$.jumpList = cbf.makelist({cbf.emit("br label @"), FIRST});
          $$.startLabel = cbf.genLabel();
          int false_line = cbf.emit("br label @");
          int true_line = cbf.emit("br label @");
          $$.trueList = cbf.makelist({true_line, FIRST});
          $$.falseList = cbf.makelist({false_line, FIRST});
          $$.llvm_name = string(VAR_EMPTY_STR); }
    | NOT Exp { if(notBool($2.type)) errorMismatch(yylineno); $$.type = $2.type;
            $$.jumpList = $2.jumpList;
            $$.startLabel = $2.startLabel;
            $$.trueList = $2.falseList;
            $$.falseList = $2.trueList;            
            $$.llvm_name = string(VAR_EMPTY_STR); }
    | Exp AND 
    {
        if(notBool($1.type)) errorMismatch(yylineno);
        bpVector($1.trueList);
    }
    Exp 
    { 
        if(notBool($4.type)) errorMismatch(yylineno); 
        $$.type=$1.type; 
        $$.llvm_name = VAR_EMPTY_STR;
        $$.jumpList = $1.jumpList;
        $$.trueList = $4.trueList;
        $$.startLabel = $1.startLabel;
        resolve_jump_next_line(string($4.startLabel),$4.jumpList);
        $$.falseList = cbf.merge($1.falseList, $4.falseList);
        }
    | Exp OR 
    {
        if(notBool($1.type)) errorMismatch(yylineno); bpVector($1.falseList);
    } Exp 
    {  
        if(notBool($4.type)) errorMismatch(yylineno); 
        $$.type=$1.type; 
        $$.jumpList = $1.jumpList;
        $$.startLabel = $1.startLabel;
        $$.falseList = $4.falseList;
        $$.llvm_name = VAR_EMPTY_STR;
        $$.trueList = cbf.merge($1.trueList, $4.trueList);
        resolve_jump_next_line(string($4.startLabel),$4.jumpList); //todo add and understand

    }
    | Exp EQ_RELOP Exp %prec EQ_RELOP { if(notIntOrByte($1.type,$3.type)) {errorMismatch(yylineno);} $$.type = "BOOL";
        resolve_jump_next_line(string($3.startLabel),$3.jumpList); //todo add and understand.
        $$.jumpList = $1.jumpList;
        $$.startLabel = $1.startLabel;
        std::string branch_str = rgs.freshVar("branch");
        cbf.emit(branch_str + " = icmp " + opcode_to_cmd($2.name, $1.type) + " i32 " + $1.llvm_name + ", " + $3.llvm_name);
        int branch_location = cbf.emit("br i1 " + branch_str + ", label @, label @");
        $$.trueList = cbf.makelist({branch_location, FIRST});
        $$.falseList = cbf.makelist({branch_location, SECOND});
        $$.llvm_name = string(VAR_EMPTY_STR); }
    | Exp RE_RELOP Exp %prec RE_RELOP { if(notIntOrByte($1.type,$3.type)) {errorMismatch(yylineno);} $$.type = "BOOL";
        resolve_jump_next_line(string($3.startLabel),$3.jumpList); //TODO add and understand
        $$.jumpList = $1.jumpList;
        $$.startLabel = $1.startLabel;
        std::string branch_str = rgs.freshVar("branch");
        cbf.emit(branch_str + " = icmp " + opcode_to_cmd($2.name, $1.type) + " i32 " + $1.llvm_name + ", " + $3.llvm_name);
        int branch_location = cbf.emit("br i1 " + branch_str + ", label @, label @");
        $$.trueList = cbf.makelist({branch_location, FIRST});
        $$.falseList = cbf.makelist({branch_location, SECOND});
        $$.llvm_name = VAR_EMPTY_STR; }
    | LPAREN Type RPAREN Exp {   
        if(notIntOrByte($2.type,$4.type)) 
        {
            errorMismatch(yylineno);
        }
        $$.type = $2.type;
        $$.llvm_name = rgs.freshVar();
        $$.name = $4.name;
        $$.jumpList = $4.jumpList;
        $$.startLabel = $4.startLabel;
        }
    ;

%%
char* join(char* s1, char* s2)
{
    
    int str_len=strlen(s1)+strlen(s2);
    char* joined_str = (char*)malloc(sizeof(char)*(str_len+1));
    strcpy(joined_str,s1);
    strcat(joined_str,s2);
    
    //not freeing memory, might be a problem atm.

    return joined_str;
}

bool notBool( char* type)
{
    return strcmp(type,"BOOL")!=0;
}

bool byteTooLarge(int value)
{
    return value > 255;

}
bool typesDontMatch(  char* LHS_type,  char* RHS_type)
{
    if (strcmp(LHS_type,RHS_type)!=0 && ( (strcmp(LHS_type,"INT")!=0) || (strcmp(RHS_type,"BYTE")!=0) ) )
    {
        return true;
    }
    else
    {
    return false;
    }
}

bool notIntOrByte( char* converter_type,  char* converted_type)
{
    
    if((strcmp(converter_type,"INT")==0 && strcmp(converted_type,"BYTE")==0)
         ||(strcmp(converter_type,"BYTE")==0 && strcmp(converted_type,"INT")==0)
         ||(strcmp(converter_type,"INT")==0 && strcmp(converted_type,"INT")==0)
         ||(strcmp(converter_type,"BYTE")==0 && strcmp(converted_type,"BYTE")==0))
         {
            
            return false;
         }
    return true;
}

bool isVoid()
{
    string func_ret_type = _stack.getCurrentfunctionreturnType();
    return strcmp(func_ret_type.data(),"VOID")==0;
}

char* biggerType(char* first, char* second)
{
    return strcmp(second,"BYTE")==0?second:first;
}

int main()
{
    return yyparse();
}

void yyerror( const char*  s ) 
{
    errorSyn(yylineno);
}